[{"content":"\u003cp\u003eLink to the question: \u003ca href=\"https://leetcode.com/problems/last-stone-weight/description/\"\u003eLeetCode/Last-stone-weight\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIn this problem, you are given an array of integers representing the weights of stones. The goal is to simulate a game where, at each turn, the two heaviest stones are selected and either both are destroyed (if they have the same weight) or the lighter stone is destroyed, and the heavier one\u0026rsquo;s weight is updated. The process repeats until there is at most one stone left, and you need to return the weight of the last remaining stone or 0 if there are no stones left.\u003c/p\u003e\n\u003ch2 id=\"intutive-approach\"\u003eIntutive Approach\u003c/h2\u003e\n\u003cp\u003eThe forcefull approach would be to find the two largest stones, smash them and insert their value into the list again. This will be done until the length of list of stones is less than one.\nYou can then make this somewhat good by sorting the array and then pick the two largest element from the last and insert them again into the array and again sort the array to make it work in next iteration like this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elastStoneWeight\u003c/span\u003e(self, stones: List[int]) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e int:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Step 1: Sort the list of stones in ascending order\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        stones\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003esort()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Step 2: Continue the process until there are at most two stones remaining\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e len(stones) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e# Step 3: Select the two heaviest stones\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            larger \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e stones\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epop()       \u003cspan style=\"color:#75715e\"\u003e# Get the weight of the larger stone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            smaller \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e stones\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epop()      \u003cspan style=\"color:#75715e\"\u003e# Get the weight of the smaller stone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e# Step 4: Process the stones based on their weights\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e larger \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e smaller:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#75715e\"\u003e# Both stones are destroyed if they have the same weight\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#75715e\"\u003e# Create a new stone with weight equal to the difference of the two stones\u0026#39; weights\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                stones\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eappend((larger \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e smaller))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e# Step 5: Sort the stones again in ascending order\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            stones\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003esort()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Return the weight of the last remaining stone or 0 if there are no stones left\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e stones[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e stones \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow analyze the time and space complexity for the solution. The sorting takes \u003cmark\u003eO(nlog(n))\u003c/mark\u003e and the sorting is done at every iteration which is running for n times as the length of the stones list this implies that for n number of stones the sorting is done \u003cmark\u003en\u003c/mark\u003e. By calculating the time complexity comes as \u003cmark\u003eO(n\u003csup\u003e2\u003c/sup\u003elog(n))\u003c/mark\u003e.\u003c/p\u003e\n\u003cp\u003eFor space complexity is constant at no step we are using the any new array and every operation done in same array as stones so it will come to \u003cmark\u003eO(n)\u003c/mark\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003c/mark\u003eTime Complexity: O(n\u003csup\u003e2\u003c/sup\u003e log(n))\n\u003cbr\u003e\nSpace Complexity: O(n)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"max-priority-queue\"\u003eMax Priority Queue\u003c/h2\u003e\n\u003cp\u003eNow we can optimize the solution by observing the steps and what could we change different. First step while optimizing the code usually check for the repeating steps and eleminate those by using some tricks or data structures.\u003c/p\u003e\n\u003cp\u003eIn the previous solution it is obvious we are sorting the list after every iteration if we could just add the stones into the list and it will arrange itself in the correct order we could save so much time.\u003c/p\u003e\n\u003cp\u003eTo be fair there is a datasctructure which does that named as \u0026ldquo;Priority Queue\u0026rdquo; with two variants \u0026ldquo;Min Priority Queue\u0026rdquo; and \u0026ldquo;Max Priority Queue\u0026rdquo;.\u003c/p\u003e\n\u003cp\u003eA max-priority queue is a data structure that maintains a collection of elements with assigned priorities and allows efficient retrieval of the element with the highest priority. The element with the maximum priority is always dequeued first.\u003c/p\u003e\n\u003cp\u003eWe are going to use \u0026ldquo;Max Priority Queue\u0026rdquo; to be mroe specific ( but python \u003cmark\u003eheapq\u003c/mark\u003e does not support max-priority queue so we just multiply the \u003cmark\u003e-1\u003c/mark\u003e to make the largest element smallest and while getting the element we just multiply with \u003cmark\u003e-1\u003c/mark\u003e again this will ensure the calculation is correct at every step). By using this when we call two times \u003cmark\u003eheappop\u003c/mark\u003e we will get two largest element and when inserting the new element the datastructure will be correctly arranged.\u003c/p\u003e\n\u003cp\u003eGetting the largest element in Max Priority Queue takes \u003cmark\u003eO(1)\u003c/mark\u003e time and insertion takes \u003cmark\u003eO(log(n))\u003c/mark\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e heapq\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elastStoneWeight\u003c/span\u003e(self, stones: List[int]) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e int:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Initialize a max heap, push negation of stone weights, and update heap after each smashing operation\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        heap \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e stones:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappush(heap, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e i)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e len(heap) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            y \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappop(heap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappop(heap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e y:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappush(heap, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e (y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e x))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e heap[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e heap \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# Return the weight of the last remaining stone or 0 if no stones left\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow analyze the time and space complexity for the solution. The heap operations take \u003cmark\u003eO(log n)\u003c/mark\u003e, and the loop iterates until there is at most one stone left, resulting in a total time complexity of \u003cmark\u003eO(nlog(n))\u003c/mark\u003e due to the heap operations. The space complexity is O(n) as the heap stores the negation of stone weights.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTime Complexity: O(nlog(n))\n\u003cbr\u003e\nSpace Complexity: O(n)\u003c/p\u003e\n\u003c/blockquote\u003e\n","description":null,"image":"/images/blogs/post2/img1.png","permalink":"https://Exoutia.github.io/blogs/last-stone-weight/","title":"Last Stone Weight"},{"content":"\u003cp\u003eThis is a simple software design problem in \u003ca href=\"https://leetcode.com/problems/kth-largest-element-in-a-stream/description/\"\u003eLeetCode\u003c/a\u003e.\nSo according to problem we have to create a datastruccture which will return the kth_largest element every time we add element in this datastructure.\u003c/p\u003e\n\u003ch2 id=\"intutive-approach\"\u003eIntutive Approach\u003c/h2\u003e\n\u003cp\u003eThis soltuion can be pretty intutive just insert the new element and sort the list in reverse order and return the array the \u003cmark\u003eK\u003c/mark\u003e index element.\u003c/p\u003e\n\u003cp\u003eThe code would look like this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ekthLargest\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e __init__(self, k: int, nums: list[int]):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ek \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e k\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enums \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(self, n: int) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e int:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enums\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eappend(n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enums\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003esort(reverse\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e len(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enums) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ek:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enums[k\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enums[\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTime Complexity: O(nlog(n))\u003c/strong\u003e\n\u003cbr/\u003e\n\u003cstrong\u003eSpace Complexity: O(n)\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"using-priority-queue\"\u003eUsing Priority Queue\u003c/h2\u003e\n\u003cp\u003eNow the previous solution is fine and great but this can be improved by using Priority queue. In Priority queue removing smallest elements takes \u003cmark\u003eO(1)\u003c/mark\u003e time. So if you read the question we just need to store the top \u003cmark\u003eK\u003c/mark\u003e largest element every time a new element is added.\u003c/p\u003e\n\u003cp\u003eNow the approach should be clear that every time new data is added we remore the smallest element until the size of heap is same as k or smaller. And finally return the last element in the array.\u003c/p\u003e\n\u003cp\u003eThe code look like this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e heapq\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eKthLargest\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e __init__(self, k: int, nums: list[int]):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Initialize the class with k and a list of integers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ek \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e k\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Convert the list into a min-heap using heapq.heapify\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheapify(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Keep only the k largest elements in the heap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e len(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ek:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappop(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(self, n: int) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e int:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Add the new element to the heap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappush(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap, n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Ensure that the heap maintains the k largest elements\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e len(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ek:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            heapq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheappop(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# Return the current kth largest element, which is the smallest in the heap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eheap[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTime Complexity: O(n)\u003c/strong\u003e\n\u003cbr/\u003e\n\u003cstrong\u003eSpace Complexity: O(n)\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHope this helps you understand this prbolem.\u003c/p\u003e\n","description":null,"image":"/images/blogs/post1/img1.png","permalink":"https://Exoutia.github.io/blogs/kth-largest-element-in-a-stream/","title":"Kth Largest Element In a Stream (Leetcode)"}]