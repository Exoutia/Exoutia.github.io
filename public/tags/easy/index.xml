<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>easy on Bibek Jha</title>
    <link>https://Exoutia.github.io/tags/easy/</link>
    <description>Recent content in easy on Bibek Jha</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Dec 2023 18:25:21 +0530</lastBuildDate>
    <atom:link href="https://Exoutia.github.io/tags/easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>K Closest Points to Origin</title>
      <link>https://Exoutia.github.io/blogs/k-closest-points-to-origin/</link>
      <pubDate>Mon, 25 Dec 2023 18:25:21 +0530</pubDate>
      <guid>https://Exoutia.github.io/blogs/k-closest-points-to-origin/</guid>
      <description>This blog discusses the solution to the LeetCode problem of finding the Kth closest points to the origin.&#xA;Intuitive Approach An intuitive solution involves calculating the distance of each point from the origin, storing it with the point, and then sorting the list of points based on these distances. The Kth closest point is then retrieved from the sorted list.&#xA;Here&amp;rsquo;s the Python code for the intuitive approach:&#xA;from math import sqrt class Solution: def kClosest(self, points: List[List[int]], k: int) -&amp;gt; List[List[int]]: val = [] for i in points: x = i[0] y = i[1] val.</description>
    </item>
    <item>
      <title>Last Stone Weight</title>
      <link>https://Exoutia.github.io/blogs/last-stone-weight/</link>
      <pubDate>Sun, 24 Dec 2023 07:46:57 +0530</pubDate>
      <guid>https://Exoutia.github.io/blogs/last-stone-weight/</guid>
      <description>Link to the question: LeetCode/Last-stone-weight&#xA;In this problem, you are given an array of integers representing the weights of stones. The goal is to simulate a game where, at each turn, the two heaviest stones are selected and either both are destroyed (if they have the same weight) or the lighter stone is destroyed, and the heavier one&amp;rsquo;s weight is updated. The process repeats until there is at most one stone left, and you need to return the weight of the last remaining stone or 0 if there are no stones left.</description>
    </item>
    <item>
      <title>Kth Largest Element In a Stream (Leetcode)</title>
      <link>https://Exoutia.github.io/blogs/kth-largest-element-in-a-stream/</link>
      <pubDate>Sat, 23 Dec 2023 09:06:35 +0530</pubDate>
      <guid>https://Exoutia.github.io/blogs/kth-largest-element-in-a-stream/</guid>
      <description>This is a simple software design problem in LeetCode. So according to problem we have to create a datastruccture which will return the kth_largest element every time we add element in this datastructure.&#xA;Intutive Approach This soltuion can be pretty intutive just insert the new element and sort the list in reverse order and return the array the K index element.&#xA;The code would look like this:&#xA;class kthLargest: def __init__(self, k: int, nums: list[int]): self.</description>
    </item>
  </channel>
</rss>
